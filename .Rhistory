ext_m <- lm(sleep ~ totwrk + educ + age + I(age^2) + yngkid + male +
male:totwrk + male:educ + male:age + male:I(age^2) + male:yngkid,
data = sleep75)
anova(model_men, model_wome, ext_m)
anova(model_men, model_women, ext_m)
anova(ext_m)
anova(ext_m)$F[2]
anova(ext_m)$F
library(wooldridge)
attach(wage2)
# ii)
submodelo <- lm(log(wage) ~ educ + exper + tenure + I(exper^2) + I(tenure^2) + married + black + south + urban); summary(rlm222)
# ii)
submodelo <- lm(log(wage) ~ educ + exper + tenure + I(exper^2) + I(tenure^2) + married + black + south + urban); summary(submodelo)
install.packages('car')
library(car)
# i)
modelo_inicial <- lm(log(wage) ~ educ + exper + tenure + married + black + south + urban); summary(rlm)
linearHypothesis(modelo_inicial, join)
# ou
join <- c('I(tenure^2)', 'I(exper^2)')
linearHypothesis(modelo_inicial, join)
linearHypothesis(submodelo, join)
library(SDAResources)
data(agpop) # load the data set
names(agpop) # list the variable names
table(agpop$region) # number of counties in each stratum
popsize <- table(agpop$region)
# ou seja,
# N(1) = 1054
# N(2) = 220
# N(3) = 1382
# N(4) = 422
pop_total <- nrow(agpop)
pop_total
propalloc <- 300*popsize/sum(popsize)
propalloc
# Round to nearest integer
propalloc_int <- round(propalloc)
propalloc_int
sum(propalloc_int) # check that stratum sample sizes sum to 300
regionname <- c("NC","NE","S","W")
# Make sure sampsize has same ordering as regionname
sampsize <- c(103,21,135,41)
sampsize
for (i in 1:length(sampsize)) {
index <- c(index,sample((1:N)[agpop$region==regionname[i]],
size=sampsize[i],replace=F))
}
index <- NULL
for (i in 1:length(sampsize)) {
index <- c(index,sample((1:N)[agpop$region==regionname[i]],
size=sampsize[i],replace=F))
}
N=nrow(agpop)
# Make sure sampsize has same ordering as regionname
sampsize <- c(103,21,135,41)
# Set the seed for random number generation
set.seed(108742)
index <- NULL
for (i in 1:length(sampsize)) { # de 1 até 4
index <- c(index,sample((1:N)[agpop$region==regionname[i]], # para cada estrato
size=sampsize[i],replace=F))
}
index
index
strsample<-agpop[index,]
strsample
# Check that we have the correct stratum sample sizes
table(strsample$region)
head(strsample)
mean(strsample[strsample$region=="NC",]$acres92,na.rm=TRUE)
mean(strsample[strsample$region=="NE",]$acres92,na.rm=TRUE)
strmean<-tapply(strsample$acres92,strsample$region,mean,na.rm=TRUE)
strmean
strvar
# calculate variance within each region
strvar<-tapply(strsample$acres92,strsample$region,var,na.rm=TRUE)
strvar
strse<- sqrt((1-sampsize/popsize)*strvar/sampsize)
# same standard errors as from svyby
strse
# Check that we have the correct stratum sample sizes
table(strsample$region)
strmean
head(strsample)
strmean
est_st <- tapply((sampzise/N)*strmean)
popsize <- table(agpop$region)
popsize
pesos <- sampsize / N
pesos
popsize <- table(agpop$region)
popsize <- table(agpop$region)
popsize
pesos <- popsize / N; # wi = Ni / N
pesos <- popsize / N; # wi = Ni / N
pesos
strse
strmean
sum(pesos*strmean)
(1/N^2)*sum(popsize*(popsize-sampsize)*strvar/sampsize)
var_est <- (1/N^2)*sum(popsize*(popsize-sampsize)*strvar/sampsize) # slide 7/11 aula_estratificada
# ERRO PADRÃO
sqrt(var_est)
#
sum(sampsize*strmean)
# estimar o valor total populacional da variável acres92 usando amostragem estratificada e o respetivo erro padrão
sum(popsize*strmean)
popsize
# estimar o valor total populacional da variável acres92 usando amostragem estratificada e o respetivo erro padrão
total <- sum(popsize*strmean)
# s^2 (YTst) = N^2*S^2y_st)
N^2*total
# s^2 (YTst) = N^2*S^2y_st)
N^2*var(total)
# s^2 (YTst) = N^2*S^2y_st)
N^2*var_est
# s^2 (YTst) = N^2*S^2y_st)
var_total <- N^2*var_est
# ERRO PADRÃO
sqrt(var_total)
# ERRO PADRÃO
sqrt(var_total)
var(c(30,40,20,18,24,10,20,7,35,12))
library(ggplot)
dat <- ggplot2::mpg
source("C:/Users/elisa/Desktop/uni stuff/2ºY/ATD/Outliers.R", echo=TRUE)
#The dataset mpg from the {ggplot2} package
#we will focus on the variable hwy (highway miles per gallon).
library(ggplot2)
dat <- ggplot2::mpg
summary(dat$hwy)
hist(dat$hwy,
xlab = "hwy",
main = "Histogram of hwy",
breaks = sqrt(length(dat$hwy)) # set number of bins
)
library(ggplot2)
ggplot(dat) +
aes(x = hwy) +
geom_histogram(
bins = round(sqrt(length(dat$hwy))), # set number of bins
fill = "steelblue", color = "black"
)
boxplot(dat$hwy,
ylab = "hwy"
)
ggplot(dat) +
aes(x = hwy) +
geom_histogram(
bins = round(sqrt(length(dat$hwy))), # set number of bins
fill = "steelblue", color = "black"
)
# base dados mpg com a libraria ggplot2
dat <- ggplot2::mpg
summary(dat$hwy)
hist(dat$hwy,
xlab = "hwy",
main = "Histogram of hwy",
breaks = sqrt(length(dat$hwy)) # set number of bins
)
library(ggplot2)
ggplot(dat) +
aes(x = hwy) +
geom_histogram(
bins = round(sqrt(length(dat$hwy))), # set number of bins
fill = "steelblue", color = "black"
)
names(dat)
ggplot(dat) +
aes(x = hwy) +
geom_histogram(
bins = round(sqrt(length(dat$hwy))), # set number of bins
fill = "purple", color = "black"
)
ggplot(dat) +
aes(x = hwy) +
geom_histogram(
bins = round(sqrt(length(dat$hwy))), # set number of bins
fill = "steelblue", color = "black"
)
boxplot(dat$hwy,
ylab = "hwy"
)
out <- boxplot.stats(dat$hwy)$out
out
out_ind <- which(dat$hwy %in% c(out))
out_ind <- which(dat$hwy %in% c(out))
out_ind
dat[out_ind, ]
boxplot(dat$hwy,
ylab = "hwy",
main = "Boxplot of highway miles per gallon"
)
mtext(paste("Outliers: ", paste(out, collapse = ", ")))
lower_bound <- quantile(dat$hwy, 0.025)
lower_bound
upper_bound <- quantile(dat$hwy, 0.975)
upper_bound
outlier_ind <- which(dat$hwy < lower_bound | dat$hwy > upper_bound)
outlier_ind
outlier_ind # identificação dos outliers
dat$z_hwy <- scale(dat$hwy)
dat$z_hwy <- scale(dat$hwy) # scale --> normaliza/estandardiza os dados
which(dat$z_hwy > 3.29 )
# critério de filtro de hampel
help(mad)
lower_bound <- median(dat$hwy) - 3 * mad(dat$hwy, constant = 1)
upper_bound <- median(dat$hwy) + 3 * mad(dat$hwy, constant = 1)
outlier_ind <- which(dat$hwy < lower_bound | dat$hwy > upper_bound)
library(car)
qqPlot(dat$hwy)
install.packages("outliers")
library(outliers)
# Grubbs test
test <- grubbs.test(dat_tests)
test <- grubbs.test(dat_tests, opposite = TRUE)
#simulated dataset
dat_tests <- c(rnorm(50), 5)
# Grubbs test
test <- grubbs.test(dat_tests)
test <- grubbs.test(dat_tests, opposite = TRUE)
#Identify smallest and hightest values are outlier or not
test <- grubbs.test(dat_tests, type=11)
#Identify two large values outlier or not
test <-grubbs.test(dat_tests[1:20], type=20)
#Identify two smallest values outlier or not
grubbs.test(dat_tests[1:20], type=20,opposite=TRUE)
# subset of simulated data
subdat <- c(dat_tests[1:20], max(dat_tests))
#Identify two smallest values outlier or not
grubbs.test(dat_tests[1:20], type=20,opposite=TRUE)
#simulated dataset
dat_tests <- c(rnorm(50), 5) # gera 50 obseravções + 1 (valor 5), = 51 observações
dat_tests
set.seed(999)
dat_tests
#simulated dataset
dat_tests <- c(rnorm(50), 5) # gera 50 obseravções + 1 (valor 5), = 51 observações
dat_tests
library(outliers)
# Grubbs test
test <- grubbs.test(dat_tests)
test
test <- grubbs.test(dat_tests, opposite = TRUE)
test
#Identify smallest and hightest values are outlier or not
test <- grubbs.test(dat_tests, type=11)
test
#Identify two large values outlier or not
test <-grubbs.test(dat_tests[1:20], type=20)
test
library(SDaA)
data("htpop")
data("htstrat")
attach(hts)
attach(htstrat)
nrow(hts)
nrow(htstrat)
0.5*200
table(gender)
View(htstrat)
n2<-
mean(htstrat[htstrat$gender=="F",]$height,na.rm=TRUE)
mean(htstrat[htstrat$gender=="F",]$height,na.rm=TRUE)
mean(htstrat[htstrat$gender=="M",]$height,na.rm=TRUE)
# Carregue seus dados (substitua 'seu_data_frame.csv' pelo nome do seu arquivo CSV)
df <- read.csv("train.csv")
setwd('C:/Users/elisa/Desktop/uni stuff/2ºY/PAA/projeto PAA (vsc rep)')
# Carregue seus dados (substitua 'seu_data_frame.csv' pelo nome do seu arquivo CSV)
df <- read.csv("train.csv")
library(shiny)
library(dplyr)
library(plotly)
setwd('C:/Users/elisa/Desktop/uni stuff/2ºY/PAA/projeto PAA (vsc rep)')
# Carregue seus dados (substitua 'seu_data_frame.csv' pelo nome do seu arquivo CSV)
df <- read.csv("train.csv")
# Defina a interface Shiny
ui <- fluidPage(
titlePanel("Média de Preço para Cada Atributo"),
sidebarLayout(
sidebarPanel(
selectInput("categoria", "Escolha a Categoria:",
choices = c('brand', 'model', 'model_year', 'fuel_type', 'engine', 'transmission', 'ext_col', 'int_col', 'accident', 'clean_title'),
selected = 'brand')
),
mainPanel(
plotlyOutput("barplot")
)
)
)
# Defina o servidor Shiny
server <- function(input, output) {
# Calcular a média do preço para a categoria escolhida
media_preco <- reactive({
df %>%
group_by(.data[[input$categoria]]) %>%
summarise(media = mean(price, na.rm = TRUE)) %>%
arrange(desc(media)) %>%
head(10)
})
# Gerar o gráfico de barras interativo
output$barplot <- renderPlotly({
plot_ly(x = media_preco()$`input$categoria`, y = media_preco()$media, type = "bar", marker = list(color = 'deepskyblue')) %>%
layout(title = paste("Média de Preço por", toupper(input$categoria)),
xaxis = list(title = input$categoria),
yaxis = list(title = "Média de Preço"))
})
}
# Execute a aplicação Shiny
shinyApp(ui, server)
library(shiny)
library(dplyr)
library(plotly)
# Carregue seus dados (substitua 'seu_data_frame.csv' pelo nome do seu arquivo CSV)
df <- read.csv("seu_data_frame.csv")
df <- read.csv("train.csv")
# Defina a interface Shiny
ui <- fluidPage(
titlePanel("Média de Preço para Cada Atributo"),
sidebarLayout(
sidebarPanel(
selectInput("categoria", "Escolha a Categoria:",
choices = c('brand', 'model', 'model_year', 'fuel_type', 'engine', 'transmission', 'ext_col', 'int_col', 'accident', 'clean_title'),
selected = 'brand')
),
mainPanel(
plotlyOutput("barplot")
)
)
)
# Defina o servidor Shiny
server <- function(input, output) {
# Calcular a média do preço para a categoria escolhida
media_preco <- reactive({
df %>%
group_by(.data[[input$categoria]]) %>%
summarise(media = mean(price, na.rm = TRUE)) %>%
arrange(desc(media)) %>%
head(10) %>%
mutate(across(.cols = all_of(input$categoria), .fns = as.factor))
})
# Gerar o gráfico de barras interativo
output$barplot <- renderPlotly({
plot_ly(x = media_preco()$`input$categoria`, y = media_preco()$media, type = "bar", marker = list(color = 'deepskyblue')) %>%
layout(title = paste("Média de Preço por", toupper(input$categoria)),
xaxis = list(title = input$categoria),
yaxis = list(title = "Média de Preço"))
})
}
# Execute a aplicação Shiny
shinyApp(ui, server)
# Defina a interface Shiny
ui <- fluidPage(
titlePanel("Média de Preço para Cada Atributo"),
sidebarLayout(
sidebarPanel(
selectInput("categoria", "Escolha a Categoria:",
choices = c('brand', 'model', 'model_year', 'fuel_type', 'engine', 'transmission', 'ext_col', 'int_col', 'accident', 'clean_title'),
selected = 'brand')
),
mainPanel(
plotlyOutput("barplot")
)
)
)
# Defina o servidor Shiny
server <- function(input, output) {
# Calcular a média do preço para a categoria escolhida
media_preco <- reactive({
df %>%
group_by(.data[[input$categoria]]) %>%
summarise(media = mean(price, na.rm = TRUE)) %>%
arrange(desc(media)) %>%
head(10) %>%
mutate(across(.cols = all_of(input$categoria), .fns = as.factor))
})
# Gerar o gráfico de barras interativo
output$barplot <- renderPlotly({
plot_ly(x = media_preco()$`input$categoria`, y = media_preco()$media, type = "bar", marker = list(color = 'deepskyblue')) %>%
layout(title = paste("Média de Preço por", toupper(input$categoria)),
xaxis = list(title = input$categoria, tickvals = 1:10, ticktext = media_preco()$`input$categoria`),
yaxis = list(title = "Média de Preço"))
})
}
# Execute a aplicação Shiny
shinyApp(ui, server)
# Execute a aplicação Shiny
shinyApp(ui, server)
# Execute a aplicação Shiny
shinyApp(ui, server)
library(shiny)
library(dplyr)
library(plotly)
# Carregue seus dados (substitua 'seu_data_frame.csv' pelo nome do seu arquivo CSV)
df <- read.csv("train.csv")
ui <- fluidPage(
titlePanel("Média de Preço para Cada Atributo"),
sidebarLayout(
sidebarPanel(
selectInput("categoria", "Escolha a Categoria:",
choices = c('brand', 'model', 'model_year', 'fuel_type', 'engine', 'transmission', 'ext_col', 'int_col', 'accident', 'clean_title'),
selected = 'brand')
),
mainPanel(
plotlyOutput("barplot")
)
)
)
# Defina o servidor Shiny
server <- function(input, output) {
# Calcular a média do preço para a categoria escolhida
media_preco <- reactive({
df %>%
group_by(.data[[input$categoria]]) %>%
summarise(media = mean(price, na.rm = TRUE)) %>%
arrange(desc(media)) %>%
head(10) %>%
mutate(across(.cols = all_of(input$categoria), .fns = as.factor))
})
# Gerar o gráfico de barras interativo
output$barplot <- renderPlotly({
plot_ly(x = as.character(media_preco()$`input$categoria`), y = media_preco()$media, type = "bar", marker = list(color = 'deepskyblue')) %>%
layout(title = paste("Média de Preço por", toupper(input$categoria)),
xaxis = list(title = input$categoria, tickvals = 1:10, ticktext = media_preco()$`input$categoria`),
yaxis = list(title = "Média de Preço"),
annotations = list(
x = 0.5, y = -0.15, showarrow = FALSE,
text = paste("Legenda: 1 - ", media_preco()$`input$categoria`[1], ", 2 - ", media_preco()$`input$categoria`[2], ", ..."),
xref = "paper", yref = "paper"
)
)
})
}
# Execute a aplicação Shiny
shinyApp(ui, server)
# Defina a interface Shiny
ui <- fluidPage(
titlePanel("Média de Preço para Cada Atributo"),
sidebarLayout(
sidebarPanel(
selectInput("categoria", "Escolha a Categoria:",
choices = c('brand', 'model', 'model_year', 'fuel_type', 'engine', 'transmission', 'ext_col', 'int_col', 'accident', 'clean_title'),
selected = 'brand')
),
mainPanel(
plotlyOutput("barplot")
)
)
)
# Defina o servidor Shiny
server <- function(input, output) {
# Calcular a média do preço para a categoria escolhida
media_preco <- reactive({
df %>%
group_by(.data[[input$categoria]]) %>%
summarise(media = mean(price, na.rm = TRUE)) %>%
arrange(desc(media)) %>%
head(10) %>%
mutate(across(.cols = all_of(input$categoria), .fns = as.factor))
})
# Gerar o gráfico de barras interativo
output$barplot <- renderPlotly({
plot_ly(x = as.character(media_preco()$`input$categoria`), y = media_preco()$media, type = "bar", marker = list(color = 'deepskyblue')) %>%
layout(title = paste("Média de Preço por", toupper(input$categoria)),
xaxis = list(title = input$categoria),
yaxis = list(title = "Média de Preço"))
})
}
# Execute a aplicação Shiny
shinyApp(ui, server)
library(shiny)
library(dplyr)
library(plotly)
# Carregue seus dados (substitua 'seu_data_frame.csv' pelo nome do seu arquivo CSV)
df <- read.csv("train.csv")
# Defina a interface Shiny
ui <- fluidPage(
titlePanel("Média de Preço para Cada Atributo"),
sidebarLayout(
sidebarPanel(
selectInput("categoria", "Escolha a Categoria:",
choices = c('brand', 'model', 'model_year', 'fuel_type', 'engine', 'transmission', 'ext_col', 'int_col', 'accident', 'clean_title'),
selected = 'brand')
),
mainPanel(
plotlyOutput("barplot")
)
)
)
# Defina o servidor Shiny
server <- function(input, output) {
# Calcular a média do preço para a categoria escolhida
media_preco <- reactive({
df %>%
group_by(.data[[input$categoria]]) %>%
summarise(media = mean(price, na.rm = TRUE)) %>%
arrange(desc(media)) %>%
head(10) %>%
mutate(across(.cols = all_of(input$categoria), .fns = as.factor))
})
# Gerar o gráfico de barras interativo
output$barplot <- renderPlotly({
plot_ly(x = as.character(media_preco()$`input$categoria`), y = media_preco()$media, type = "bar", marker = list(color = 'deepskyblue')) %>%
layout(title = paste("Média de Preço por", toupper(input$categoria)),
xaxis = list(title = input$categoria),
yaxis = list(title = "Média de Preço"))
})
}
# Execute a aplicação Shiny
shinyApp(ui, server)
